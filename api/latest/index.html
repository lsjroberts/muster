<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Muster</title>
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="assets/css/main.css">
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="assets/js/search.js" data-base=".">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="index.html" class="title">Muster</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-only-exported" />
							<label class="tsd-widget" for="tsd-filter-only-exported">Only exported</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="globals.html">Globals</a>
				</li>
			</ul>
			<h1> Muster</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<div class="tsd-panel tsd-typography">
				<h1 id="muster">Muster</h1>
				<h2 id="a-universal-data-layer-for-your-components-and-services">A universal data layer for your components and services</h2>
				<blockquote>
					<p>Muster is a state and data management library that gives you a unified, reactive, declarative,
					performant and powerful view of as much or as little data as you need.</p>
				</blockquote>
				<p>Muster comes bundled with a number of <a href="interfaces/muster.nodedefinition.html">NodeDefinition</a>s split into following categories:</p>
				<ul>
					<li>arithmetic - Nodes focusing on arithmetic operations, e.g. <a href="modules/muster.html#add">add</a>, <a href="modules/muster.html#subtract">subtract</a>, etc.</li>
					<li>browser - Nodes used for interacting with the browser, e.g. [[location]]</li>
					<li>collections - Nodes that are handling collections and all of the transformations on it, e.g.
					<a href="modules/muster.html#applytransforms-1">applyTransforms</a>, <a href="modules/muster.html#filter-1">filter</a>, <a href="modules/muster.html#sort">sort</a>, <a href="modules/muster.html#map">map</a>, etc.</li>
					<li>graph - Core Muster nodes, e.g. [[ref]], <a href="modules/muster.html#variable">variable</a>, [[value]], <a href="modules/muster.html#action-2">action</a>, etc.</li>
					<li>logic - Nodes introducing logic operators, e.g. <a href="modules/muster.html#and">and</a>, <a href="modules/muster.html#eq">eq</a>, <a href="modules/muster.html#ifelse">ifElse</a>, etc.</li>
					<li>numeric - Nodes helping with handling numbers in Muster, e.g. <a href="modules/muster.html#parseint">parseInt</a></li>
					<li>remote - Nodes used for connecting Muster with remote Muster instances, e.g. <a href="modules/muster.html#proxy">proxy</a>.</li>
					<li>string - String manipulation nodes, e.g. <a href="modules/muster.html#endswith">endsWith</a>, <a href="interfaces/muster.serializedarray.html#join">join</a>, <a href="modules/muster.html#split">split</a>, etc.</li>
				</ul>
				<h2 id="installation">Installation</h2>
				<pre><code class="language-bash">npm install --save @dws/muster @dws/muster-observable</code></pre>
				<h2 id="usage">Usage</h2>
				<p><strong>Creating basic muster application</strong></p>
				<pre><code class="language-js"><span class="hljs-keyword">import</span> muster <span class="hljs-keyword">from</span> <span class="hljs-string">'@dws/muster'</span>;

<span class="hljs-keyword">const</span> app = muster({
  <span class="hljs-attr">firstName</span>: <span class="hljs-string">'John'</span>,
  <span class="hljs-attr">lastName</span>: <span class="hljs-string">'Doe'</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">43</span>,
});</code></pre>
				<p>This example creates a muster application containing three nodes:</p>
				<ul>
					<li><code>firstName</code>: [[value]] = <code>&#39;John&#39;</code></li>
					<li><code>lastName</code>: [[value]] = <code>&#39;Doe&#39;</code></li>
					<li><code>age</code>: [[value]] = <code>43</code></li>
				</ul>
				<p><strong>Accessing data from a muster graph</strong></p>
				<pre><code class="language-js"><span class="hljs-keyword">const</span> app = muster({ <span class="hljs-attr">firstName</span>: <span class="hljs-string">'John'</span> });</code></pre>
				<p>First let&#39;s create a simple muster instance with a graph containing a single leaf [[value]]
				<code>firstName</code>. Now we have an instance of muster we can make queries against it:</p>
				<pre><code class="language-js"><span class="hljs-keyword">const</span> firstName = <span class="hljs-keyword">await</span> app.resolve(ref(<span class="hljs-string">'firstName'</span>));</code></pre>
				<p>The <a href="classes/muster.muster-1.html">Muster</a> object exposes a <code>resolve</code> method which can be used for running queries against
					muster. In this example we&#39;ve used a [[ref]]. This node is used to locate and return a graph
					node based on its path in the graph. The path in the graph is defined by the hierarchy of branches
					that exist in the muster graph. In this example we have just one branch containing a single leaf
					<code>firstName</code>. You can find out more about paths and branches in the [[ref]] and <a href="modules/muster.html#tree">tree</a>
				documentation.</p>
				<p><code>app.resolve</code> returns an object implementing both <a href="classes/muster_observable.observable.html">Observable</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a> APIs.
					In this example we have retrieved the current value of the <code>firstName</code> node with the use of the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a> API.
				Alternatively this can also be done with <a href="classes/muster_observable.observable.html">Observable</a> by subscribing to the returned observable:</p>
				<pre><code class="language-js"><span class="hljs-keyword">const</span> unsubscribe = app.resolve(ref(<span class="hljs-string">'firstName'</span>)).subscribe(<span class="hljs-function">(<span class="hljs-params">firstName</span>) =&gt;</span> {
  <span class="hljs-comment">// Do something with the first name as it changes over time</span>
});</code></pre>
				<p>By nature, muster tries to execute the code synchronously when it can, so the callback of the
					<code>subscribe</code> will be called immediately with the latest value of <code>firstName</code>.
				In this example <code>firstName</code> resolves to <code>&#39;John&#39;</code> string.</p>
				<p><strong>Notice:</strong> <code>subscribe</code> has one important advantage over <code>await</code>. It responds to changes in the
					subscribed query over time. Consider an example where the <code>firstName</code> is a node whose value
					changes while the application is running. <code>Promise</code> will emit the value as soon as it&#39;s
					available but won&#39;t cause your code to be re-run when the value of the subscribed node changes.
					On the other hand, <a href="classes/muster_observable.observable.html">Observable</a> will re-emit a new value causing the subscriber (the function used
				to create the subscription) to be executed again with a new value.</p>
				<p>See <a href="modules/muster.html#variable">variable</a>, <a href="modules/muster.html#frompromise">fromPromise</a> and <a href="modules/muster.html#fromstream">fromStream</a> for more information about
				settable nodes.</p>
				<p><strong>Creating muster application with branches</strong></p>
				<pre><code class="language-js"><span class="hljs-keyword">import</span> muster, { computed, ref } <span class="hljs-keyword">from</span> <span class="hljs-string">'@dws/muster'</span>;

<span class="hljs-keyword">const</span> app = muster({
  <span class="hljs-attr">user</span>: {
    <span class="hljs-attr">firstName</span>: <span class="hljs-string">'John'</span>,
    <span class="hljs-attr">lastName</span>: <span class="hljs-string">'Doe'</span>,
    <span class="hljs-attr">fullName</span>: computed([
      ref(<span class="hljs-string">'user'</span>, <span class="hljs-string">'firstName'</span>),
      ref(<span class="hljs-string">'user'</span>, <span class="hljs-string">'lastName'</span>),
    ], (firstName, lastName) =&gt; <span class="hljs-string">`<span class="hljs-subst">${firstName}</span> <span class="hljs-subst">${lastName}</span>`</span>),
  },
});</code></pre>
				<p>This example creates a muster application where the graph has one branch <code>user</code> (<a href="modules/muster.html#tree">tree</a>).
				That branch has three leaves:</p>
				<ul>
					<li><code>firstName</code>: [[value]] = <code>&#39;John&#39;</code></li>
					<li><code>lastname</code>: [[value]] = <code>&#39;Doe&#39;</code></li>
					<li><code>fullName</code>: <a href="modules/muster.html#computed">computed</a> = A node which computes full name of the user based on the current
					value of <code>firstName</code> and <code>lastName</code>.</li>
				</ul>
				<p>Note the <code>fullName</code> <a href="modules/muster.html#computed">computed</a> dependencies are defined using fully qualified path of the
					nodes in the graph. This could have been simplified with the use of a <a href="modules/muster.html#relative">relative</a> helper
				function:</p>
				<pre><code class="language-js"><span class="hljs-keyword">import</span> muster, { computed, ref, relative } <span class="hljs-keyword">from</span> <span class="hljs-string">'@dws/muster'</span>;

<span class="hljs-keyword">const</span> app = muster({
  <span class="hljs-attr">user</span>: {
    <span class="hljs-attr">firstName</span>: <span class="hljs-string">'John'</span>,
    <span class="hljs-attr">lastName</span>: <span class="hljs-string">'Doe'</span>,
    <span class="hljs-attr">fullName</span>: computed([
      ref(relative(<span class="hljs-string">'firstName'</span>)),
      ref(relative(<span class="hljs-string">'lastName'</span>)),
    ], (firstName, lastName) =&gt; <span class="hljs-string">`<span class="hljs-subst">${firstName}</span> <span class="hljs-subst">${lastName}</span>`</span>),
  },
});</code></pre>
				<p>The benefit of using <a href="modules/muster.html#relative">relative</a> instead of defining the full path is apparent when refactoring the
					application graph. Imagine a scenario when the <code>user</code> branch is to be renamed to <code>currentUser</code>.
					In this scenario, when the full path is used we&#39;d have to change the name in three places: branch
					definitions and both references.
					It would be much simpler with the use of <a href="modules/muster.html#relative">relative</a> helper: we&#39;d have to only rename the
				branch.</p>
				<p>You can find out more about <a href="modules/muster.html#relative">relative</a> helper on its documentation.</p>
				<p><strong>Lazy-evaluating values</strong></p>
				<pre><code class="language-js"><span class="hljs-keyword">import</span> muster, { computed, ref } <span class="hljs-keyword">from</span> <span class="hljs-string">'@dws/muster'</span>;

<span class="hljs-keyword">let</span> externalValue = <span class="hljs-string">'initial'</span>;

<span class="hljs-keyword">const</span> app = muster({
  <span class="hljs-attr">testComputed</span>: computed([], () =&gt; {
    externalValue = <span class="hljs-string">'updated'</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }),
});

<span class="hljs-comment">// externalValue === 'initial'</span>
<span class="hljs-keyword">const</span> subscription = app.resolve(ref(<span class="hljs-string">'testComputed'</span>));

<span class="hljs-comment">// externalValue === 'initial'</span>

<span class="hljs-keyword">const</span> unsubscribe = subscription.subscribe(<span class="hljs-function">(<span class="hljs-params">testComputedValue</span>) =&gt;</span> {
  <span class="hljs-comment">// externalValue === 'updated'</span>
  <span class="hljs-comment">// testComputedValue === true</span>
});
<span class="hljs-comment">// externalValue === 'updated'</span></code></pre>
				<p>This example demonstrates the principle of lazy evaluation in muster. In muster the value of
					every node is evaluated only when a subscription is created to that node. Note how the value of
					<code>externalValue</code> changes in this example. Thanks to the synchronous code execution in muster the
					<code>externalValue</code> is set to the new value before the first line of the subscriber callback as well
				as after the call to the <code>subscribe</code> method.</p>
				<p>Most of the Muster <a href="interfaces/muster.nodedefinition.html">NodeDefinition</a>s are synchronous, with exception of <a href="modules/muster.html#frompromise">fromPromise</a>,
					<a href="modules/muster.html#fromstream">fromStream</a> (depending on the type of stream used), <a href="modules/muster.html#action-2">action</a>, <a href="modules/muster.html#proxy">proxy</a> and
				<a href="modules/muster.html#remote">remote</a>.</p>
				<p><strong>Complex queries</strong></p>
				<pre><code class="language-js"><span class="hljs-keyword">import</span> muster, { key, query, root } <span class="hljs-keyword">from</span> <span class="hljs-string">'@dws/muster'</span>;

<span class="hljs-keyword">const</span> app = muster({
  <span class="hljs-attr">user</span>: {
    <span class="hljs-attr">firstName</span>: <span class="hljs-string">'Bob'</span>,
    <span class="hljs-attr">lastName</span>: <span class="hljs-string">'Johnson'</span>,
  },
});

<span class="hljs-keyword">const</span> userTree = <span class="hljs-keyword">await</span> app.resolve(query(root(), {
  <span class="hljs-attr">user</span>: key(<span class="hljs-string">'user'</span>, {
    <span class="hljs-attr">firstName</span>: key(<span class="hljs-string">'firstName'</span>),
    <span class="hljs-attr">lastName</span>: key(<span class="hljs-string">'lastName'</span>),
  }),
}));
<span class="hljs-comment">// userTree is a JS object with all of the requested branches encoded in it:</span>
<span class="hljs-comment">// {</span>
<span class="hljs-comment">//   user: {</span>
<span class="hljs-comment">//     firstName: 'Bob',</span>
<span class="hljs-comment">//     lastName: 'Johnson',</span>
<span class="hljs-comment">//   },</span>
<span class="hljs-comment">// }</span></code></pre>
				<p>In previous examples we&#39;ve been requesting a single <a href="interfaces/muster.nodedefinition.html">NodeDefinition</a> at a time. In real world apps
					this would not be the most efficient or fastest way of writing code. For this reason Muster
					comes with a <a href="modules/muster.html#query">query</a> which allows for building complex queries. These queries define the
					shape of their output data as well as the place from the graph this data is to be retrieved from. See
				the <a href="modules/muster.html#query">query</a> documentation to learn more about queries.</p>
			</div>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="globals.html"><em>Globals</em></a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/muster.html">muster</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/muster_message_transport.html">muster-<wbr>message-<wbr>transport</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/muster_observable.html">muster-<wbr>observable</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/muster_parser.html">muster-<wbr>parser</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/muster_react.html">muster-<wbr>react</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/muster_remote.html">muster-<wbr>remote</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/muster_repl.html">muster-<wbr>repl</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/muster_server.html">muster-<wbr>server</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/muster_test_utils.html">muster-<wbr>test-<wbr>utils</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/muster_worker.html">muster-<wbr>worker</a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer>
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-module"><span class="tsd-kind-icon">Module</span></li>
				<li class="tsd-kind-object-literal"><span class="tsd-kind-icon">Object literal</span></li>
				<li class="tsd-kind-variable"><span class="tsd-kind-icon">Variable</span></li>
				<li class="tsd-kind-function"><span class="tsd-kind-icon">Function</span></li>
				<li class="tsd-kind-function tsd-has-type-parameter"><span class="tsd-kind-icon">Function with type parameter</span></li>
				<li class="tsd-kind-index-signature"><span class="tsd-kind-icon">Index signature</span></li>
				<li class="tsd-kind-type-alias"><span class="tsd-kind-icon">Type alias</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-enum"><span class="tsd-kind-icon">Enumeration</span></li>
				<li class="tsd-kind-enum-member"><span class="tsd-kind-icon">Enumeration member</span></li>
				<li class="tsd-kind-property tsd-parent-kind-enum"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-enum"><span class="tsd-kind-icon">Method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-interface"><span class="tsd-kind-icon">Interface</span></li>
				<li class="tsd-kind-interface tsd-has-type-parameter"><span class="tsd-kind-icon">Interface with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-interface"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-interface"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-interface"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-class"><span class="tsd-kind-icon">Class</span></li>
				<li class="tsd-kind-class tsd-has-type-parameter"><span class="tsd-kind-icon">Class with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class"><span class="tsd-kind-icon">Accessor</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-class"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-constructor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static property</span></li>
				<li class="tsd-kind-call-signature tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static method</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="overlay"></div>
<script src="assets/js/main.js"></script>
<script>if (location.protocol == 'file:') document.write('<script src="assets/js/search.js"><' + '/script>');</script>
</body>
</html>